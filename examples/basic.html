<!-- START SIGMA IMPORTS -->
<script src="../src/sigma.core.js"></script>
<script src="../src/conrad.js"></script>
<script src="../src/utils/sigma.utils.js"></script>
<script src="../src/utils/sigma.polyfills.js"></script>
<script src="../src/sigma.settings.js"></script>
<script src="../src/classes/sigma.classes.dispatcher.js"></script>
<script src="../src/classes/sigma.classes.configurable.js"></script>
<script src="../src/classes/sigma.classes.graph.js"></script>
<script src="../src/classes/sigma.classes.camera.js"></script>
<script src="../src/classes/sigma.classes.quad.js"></script>
<script src="../src/captors/sigma.captors.mouse.js"></script>
<script src="../src/captors/sigma.captors.touch.js"></script>
<script src="../src/renderers/sigma.renderers.canvas.js"></script>
<script src="../src/renderers/sigma.renderers.webgl.js"></script>
<script src="../src/renderers/sigma.renderers.svg.js"></script>
<script src="../src/renderers/sigma.renderers.def.js"></script>
<script src="../src/renderers/webgl/sigma.webgl.nodes.def.js"></script>
<script src="../src/renderers/webgl/sigma.webgl.nodes.fast.js"></script>
<script src="../src/renderers/webgl/sigma.webgl.edges.def.js"></script>
<script src="../src/renderers/webgl/sigma.webgl.edges.fast.js"></script>
<script src="../src/renderers/webgl/sigma.webgl.edges.arrow.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.labels.def.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.hovers.def.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.nodes.def.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.edges.def.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.edges.curve.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.edges.arrow.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.edges.curvedArrow.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.edgehovers.def.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.edgehovers.curve.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.edgehovers.arrow.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.edgehovers.curvedArrow.js"></script>
<script src="../src/renderers/canvas/sigma.canvas.extremities.def.js"></script>
<script src="../src/renderers/svg/sigma.svg.utils.js"></script>
<script src="../src/renderers/svg/sigma.svg.nodes.def.js"></script>
<script src="../src/renderers/svg/sigma.svg.edges.def.js"></script>
<script src="../src/renderers/svg/sigma.svg.edges.curve.js"></script>
<script src="../src/renderers/svg/sigma.svg.labels.def.js"></script>
<script src="../src/renderers/svg/sigma.svg.hovers.def.js"></script>
<script src="../src/middlewares/sigma.middlewares.rescale.js"></script>
<script src="../src/middlewares/sigma.middlewares.copy.js"></script>
<script src="../src/misc/sigma.misc.animation.js"></script>
<script src="../src/misc/sigma.misc.bindEvents.js"></script>
<script src="../src/misc/sigma.misc.bindDOMEvents.js"></script>
<script src="../src/misc/sigma.misc.drawHovers.js"></script>
<!-- END SIGMA IMPORTS -->
<div id="container">
  <style>
    #graph-container {
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      position: absolute;
    }
  </style>
  <div id="graph-container"></div>
</div>
<script>
/**
 * This is a basic example on how to instantiate sigma. A random graph is
 * generated and stored in the "graph" variable, and then sigma is instantiated
 * directly with the graph.
 *
 * The simple instance of sigma is enough to make it render the graph on the on
 * the screen, since the graph is given directly to the constructor.
 */
var i,
    s,
    N = 10000,
    E = 0,
    g = {
      nodes: [],
      edges: []
    };

// Generate a random graph:
for (i = 0; i < N; i++)
  g.nodes.push({
    id: 'n' + i,
    label: 'Node ' + i,
    x: Math.random() * 0.9,
    y: Math.random() * 0.9,
    size: 10,
    color: '#666'
  });

for (i = 0; i < E; i++)
  g.edges.push({
    id: 'e' + i,
    source: 'n' + (Math.random() * N | 0),
    target: 'n' + (Math.random() * N | 0),
    size: Math.random(),
    color: '#ccc'
  });

  var bm = [ 0 ];

  // Instantiate sigma:
  s = new sigma({
    graph: g,
    container: 'graph-container'
  });

  function truncate(nb) {
    return Math.round(nb * 1000) / 1000;
  }

  function toPercent(nb) {
    return Math.round(nb * 100);
  }

  /* Current approximate label node rendering for 10.000 nodes: 35 ms */
  /* Current approximate rendering time without labels: 50 ms */

  function fullBenchmark() {
    console.log('Benchmark:');
    var without_label = benchmark('without labels', {drawLabels:false});
    var full_display = benchmark('with labels', {});
    //var with_opti = benchmark('with label optimization', {labelOpti:true});

    var current_label_time = toPercent((full_display - without_label) / 35);
    console.log('* Currently takes ' + current_label_time + '% of the total label rendering.');
//    var opti_label_time = truncate(with_opti - without_label);
//    var opti_time_saving = truncate(full_display - with_opti);
//    var opti_percent_total = toPercent((with_opti - without_label) / (full_display - without_label));
    //var percent_saving_labels = toPercent(opti_time_saving / current_label_time);

//    console.log('---');
//    console.log('* Labels rendering duration: ' + truncate(full_display - without_label) + 'ms (' + (100 - toPercent(without_label / full_display)) + '% of total rendering time).');
//    console.log('* Labels rendering duration with optimization: ' + opti_label_time + ' ms.');
//    console.log('* The optimization saves: ' + opti_time_saving + ' ms.');
//    console.log('* Opti uses ' + opti_percent_total + '% time.');
    //console.log('* ' + percent_saving_labels + '% time saved on the labels rendering.');
  }

  function benchmark() {
    var nbLoops = 100;

    var sum = [];

    console.log('Benchmarking...');

    for (var i = 0; i < nbLoops; ++i) {
      bm = [ performance.now() ];
      s.renderers[0].render();
      bm.push(performance.now());

      for (var j = 0; j < bm.length - 1; ++j) {
        var time = bm[j+1] - bm[j];
        if (sum[j] === undefined) {
          sum[j] = 0;
        }
        sum[j] += time;
      }
    }

    for (var k = 0; k < sum.length; ++k) {
      console.log('* Section ' + k + '-' + (k + 1) + ': ' + truncate(sum[k] / nbLoops) + ' ms.');
    }
  }

  function renderNormal() {
    s.renderers[0].render();
  }

  function renderOpti() {
    s.renderers[0].render({labelOpti:true});
  }
</script>
